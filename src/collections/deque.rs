// use crate::error::Result;
// use crate::Store;
// use byteorder::{BigEndian};
// use error_chain::bail;

// #[derive(Debug)]
pub struct Deque {
    
}

// impl Deque {
//     // pub fn new() -> Self {
//     //     Deque {}
//     // }
//     pub fn push(store: &mut impl Store) -> Result<()> {
//         match store.get(b"deque")? {
//             Some(indices) => indices[1]
//         }
//         store.put()

//     }
// }

// #[cfg(test)]
// mod tests {
//     use super::*;

//     #[test]
//     fn practice() {
//         // let d = Deque::new();
//         // println!("deque: {:?}", d)
//         println!("ok")
//     }
// }

